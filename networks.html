<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAND 2020+ Network Analysis</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            line-height: 1.6;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 40px;
        }
        .header {
            text-align: center;
            border-bottom: 3px solid #0073e6;
            padding-bottom: 30px;
            margin-bottom: 40px;
        }
        .header h1 {
            color: #0073e6;
            margin: 0;
            font-size: 2.5em;
        }
        .header p {
            font-size: 1.2em;
            color: #666;
            margin: 10px 0 0 0;
        }
        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }
        .nav-btn {
            background: #0073e6;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            text-decoration: none;
            display: inline-block;
            transition: background 0.3s;
        }
        .nav-btn:hover {
            background: #0056b3;
        }
        .nav-btn.current {
            background: #28a745;
        }
        .controls-panel {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            align-items: end;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        .control-group label {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        .control-group select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }
        .control-group select:focus {
            border-color: #0073e6;
            outline: none;
        }
        .network-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-card h3 {
            margin: 0 0 5px 0;
            font-size: 1.8em;
        }
        .stat-card p {
            margin: 0;
            opacity: 0.9;
            font-size: 0.9em;
        }
        .visualization-container {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            position: relative;
            height: 700px;
            overflow: hidden;
        }
        .network-svg {
            width: 100%;
            height: 100%;
        }
        .node {
            cursor: pointer;
            stroke-width: 2px;
        }
        .node.author {
            fill: #0073e6;
            stroke: #005bb5;
        }
        .node.method {
            fill: #28a745;
            stroke: #1e7e34;
        }
        .node.ai {
            fill: #dc3545;
            stroke: #c82333;
        }
        .node.topic {
            fill: #ffc107;
            stroke: #e0a800;
        }
        .node.unit {
            fill: #6f42c1;
            stroke: #5a2a8a;
        }
        .node:hover {
            stroke-width: 3px;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1px;
        }
        .link.highlighted {
            stroke: #0073e6;
            stroke-opacity: 0.8;
            stroke-width: 2px;
        }
        .node-label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 10px;
            fill: #333;
            text-anchor: middle;
            pointer-events: none;
        }
        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #666;
        }
        .network-info {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .network-info h3 {
            color: #0073e6;
            margin-top: 0;
        }
        @media (max-width: 768px) {
            .controls-panel {
                grid-template-columns: 1fr;
            }
            .nav-buttons {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üï∏Ô∏è RAND 2020+ Network Analysis</h1>
            <p>Interactive Network Visualizations of Research Relationships</p>
        </div>
        
        <div class="nav-buttons">
            <a href="index.html" class="nav-btn">üìñ Overview</a>
            <a href="tables.html" class="nav-btn">üìä Key Findings</a>
            <a href="dashboard.html" class="nav-btn">üîç Interactive Dashboard</a>
            <a href="networks.html" class="nav-btn current">üï∏Ô∏è Network Analysis</a>
        </div>

        <div class="network-info">
            <h3>About Network Analysis</h3>
            <p>
                This page provides interactive network visualizations showing relationships between authors, research methods, AI technologies, topics, and organizational units. 
                Networks help identify collaboration patterns, methodological expertise, and knowledge flows within RAND research.
            </p>
        </div>

        <div class="controls-panel">
            <div class="control-group">
                <label for="networkType">üéØ Network Type:</label>
                <select id="networkType">
                    <option value="author-method">Author ‚Üî Method Relationships</option>
                    <option value="author-author">Author Collaboration Network</option>
                    <option value="method-method">Method Co-occurrence Network</option>
                    <option value="author-topic">Author ‚Üî Topic Relationships</option>
                    <option value="method-ai">Method ‚Üî AI Technology</option>
                    <option value="unit-method">Unit ‚Üî Method Relationships</option>
                    <option value="temporal-author">Author Activity Over Time</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="nodeThreshold">üìä Node Threshold:</label>
                <select id="nodeThreshold">
                    <option value="5">Show nodes with 5+ connections</option>
                    <option value="10" selected>Show nodes with 10+ connections</option>
                    <option value="20">Show nodes with 20+ connections</option>
                    <option value="50">Show nodes with 50+ connections</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="layoutType">üé® Layout Algorithm:</label>
                <select id="layoutType">
                    <option value="force" selected>Force-Directed Layout</option>
                    <option value="circular">Circular Layout</option>
                    <option value="hierarchical">Hierarchical Layout</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="colorScheme">üé® Color Scheme:</label>
                <select id="colorScheme">
                    <option value="type" selected>Color by Node Type</option>
                    <option value="degree">Color by Degree (Connections)</option>
                    <option value="community">Color by Community</option>
                </select>
            </div>
        </div>

        <div class="network-stats" id="networkStats">
            <div class="stat-card">
                <h3 id="nodeCount">-</h3>
                <p>Nodes</p>
            </div>
            <div class="stat-card">
                <h3 id="linkCount">-</h3>
                <p>Links</p>
            </div>
            <div class="stat-card">
                <h3 id="avgDegree">-</h3>
                <p>Avg Degree</p>
            </div>
            <div class="stat-card">
                <h3 id="density">-</h3>
                <p>Density</p>
            </div>
        </div>

        <div class="visualization-container">
            <div class="loading" id="loading">Loading network data...</div>
            <svg class="network-svg" id="networkSvg"></svg>
            <div class="legend" id="legend"></div>
        </div>
    </div>

    <script>
        // Global variables
        let currentData = null;
        let simulation = null;
        let svg, g, link, node, nodeLabel;
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            initializeVisualization();
            loadNetworkData();
            
            // Event listeners
            document.getElementById('networkType').addEventListener('change', loadNetworkData);
            document.getElementById('nodeThreshold').addEventListener('change', updateVisualization);
            document.getElementById('layoutType').addEventListener('change', updateLayout);
            document.getElementById('colorScheme').addEventListener('change', updateColors);
        });

        function initializeVisualization() {
            const container = document.querySelector('.visualization-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            svg = d3.select('#networkSvg')
                .attr('width', width)
                .attr('height', height);
            
            g = svg.append('g');
            
            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', function(event) {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // Create simulation
            simulation = d3.forceSimulation()
                .force('link', d3.forceLink().id(d => d.id).distance(50))
                .force('charge', d3.forceManyBody().strength(-100))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(15));
        }

        function loadNetworkData() {
            const networkType = document.getElementById('networkType').value;
            document.getElementById('loading').style.display = 'block';
            
            // Generate synthetic network data based on the research data
            generateNetworkData(networkType).then(data => {
                currentData = data;
                updateVisualization();
                document.getElementById('loading').style.display = 'none';
            });
        }

        async function generateNetworkData(networkType) {
            // This would normally load from actual data files
            // For now, generating representative synthetic data based on our research
            
            const data = { nodes: [], links: [] };
            
            switch(networkType) {
                case 'author-method':
                    return generateAuthorMethodNetwork();
                case 'author-author':
                    return generateAuthorCollaborationNetwork();
                case 'method-method':
                    return generateMethodCooccurrenceNetwork();
                case 'author-topic':
                    return generateAuthorTopicNetwork();
                case 'method-ai':
                    return generateMethodAINetwork();
                case 'unit-method':
                    return generateUnitMethodNetwork();
                case 'temporal-author':
                    return generateTemporalAuthorNetwork();
                default:
                    return generateAuthorMethodNetwork();
            }
        }

        function generateAuthorMethodNetwork() {
            const nodes = [];
            const links = [];
            
            // Top authors from our data
            const authors = [
                { id: 'Stephanie Brooks Holliday', type: 'author', degree: 48, docs: 68 },
                { id: 'Melissa Kay Diliberti', type: 'author', degree: 35, docs: 61 },
                { id: 'Heather L. Schwartz', type: 'author', degree: 34, docs: 60 },
                { id: 'Elizabeth D. Steiner', type: 'author', degree: 31, docs: 58 },
                { id: 'Julia H. Kaufman', type: 'author', degree: 35, docs: 56 },
                { id: 'Terry L. Schell', type: 'author', degree: 40, docs: 45 },
                { id: 'Jonathan H. Cantor', type: 'author', degree: 22, docs: 42 },
                { id: 'Bradley D. Stein', type: 'author', degree: 19, docs: 38 }
            ];
            
            // Top methods from our data
            const methods = [
                { id: 'Literature Review', type: 'method', degree: 45, docs: 909 },
                { id: 'Statistical Analysis', type: 'method', degree: 38, docs: 688 },
                { id: 'Interviews', type: 'method', degree: 25, docs: 391 },
                { id: 'Comparative Analysis', type: 'method', degree: 20, docs: 307 },
                { id: 'Surveys', type: 'method', degree: 18, docs: 195 },
                { id: 'Case Study Analysis', type: 'method', degree: 15, docs: 188 },
                { id: 'Data Analysis', type: 'method', degree: 12, docs: 177 }
            ];
            
            nodes.push(...authors, ...methods);
            
            // Generate realistic author-method connections
            authors.forEach(author => {
                // Each author uses 3-7 methods typically
                const numMethods = Math.floor(Math.random() * 5) + 3;
                const authorMethods = methods.sort(() => 0.5 - Math.random()).slice(0, numMethods);
                
                authorMethods.forEach(method => {
                    links.push({
                        source: author.id,
                        target: method.id,
                        weight: Math.floor(Math.random() * 10) + 1
                    });
                });
            });
            
            return { nodes, links };
        }

        function generateAuthorCollaborationNetwork() {
            const nodes = [];
            const links = [];
            
            // Use the same top authors
            const authors = [
                { id: 'Stephanie Brooks Holliday', type: 'author', degree: 12, docs: 68 },
                { id: 'Melissa Kay Diliberti', type: 'author', degree: 8, docs: 61 },
                { id: 'Heather L. Schwartz', type: 'author', degree: 10, docs: 60 },
                { id: 'Elizabeth D. Steiner', type: 'author', degree: 15, docs: 58 },
                { id: 'Julia H. Kaufman', type: 'author', degree: 18, docs: 56 },
                { id: 'Terry L. Schell', type: 'author', degree: 7, docs: 45 },
                { id: 'Jonathan H. Cantor', type: 'author', degree: 9, docs: 42 },
                { id: 'Bradley D. Stein', type: 'author', degree: 11, docs: 38 },
                { id: 'Rebecca L. Collins', type: 'author', degree: 6, docs: 35 },
                { id: 'Marc N. Elliott', type: 'author', degree: 8, docs: 32 }
            ];
            
            nodes.push(...authors);
            
            // Generate collaboration links (co-authorship)
            for (let i = 0; i < authors.length; i++) {
                for (let j = i + 1; j < authors.length; j++) {
                    // Some authors collaborate more than others
                    if (Math.random() < 0.3) {
                        links.push({
                            source: authors[i].id,
                            target: authors[j].id,
                            weight: Math.floor(Math.random() * 8) + 1
                        });
                    }
                }
            }
            
            return { nodes, links };
        }

        function generateMethodCooccurrenceNetwork() {
            const nodes = [];
            const links = [];
            
            const methods = [
                { id: 'Literature Review', type: 'method', degree: 25, docs: 909 },
                { id: 'Statistical Analysis', type: 'method', degree: 22, docs: 688 },
                { id: 'Interviews', type: 'method', degree: 18, docs: 391 },
                { id: 'Comparative Analysis', type: 'method', degree: 15, docs: 307 },
                { id: 'Surveys', type: 'method', degree: 12, docs: 195 },
                { id: 'Case Study Analysis', type: 'method', degree: 10, docs: 188 },
                { id: 'Data Analysis', type: 'method', degree: 14, docs: 177 },
                { id: 'Document Analysis', type: 'method', degree: 8, docs: 172 },
                { id: 'Qualitative Analysis', type: 'method', degree: 9, docs: 158 }
            ];
            
            nodes.push(...methods);
            
            // Generate method co-occurrence links
            for (let i = 0; i < methods.length; i++) {
                for (let j = i + 1; j < methods.length; j++) {
                    // Methods that commonly appear together
                    if (Math.random() < 0.4) {
                        links.push({
                            source: methods[i].id,
                            target: methods[j].id,
                            weight: Math.floor(Math.random() * 50) + 10
                        });
                    }
                }
            }
            
            return { nodes, links };
        }

        function generateAuthorTopicNetwork() {
            const nodes = [];
            const links = [];
            
            const authors = [
                { id: 'Stephanie Brooks Holliday', type: 'author', degree: 8, docs: 68 },
                { id: 'Melissa Kay Diliberti', type: 'author', degree: 6, docs: 61 },
                { id: 'Heather L. Schwartz', type: 'author', degree: 7, docs: 60 },
                { id: 'Elizabeth D. Steiner', type: 'author', degree: 5, docs: 58 },
                { id: 'Julia H. Kaufman', type: 'author', degree: 6, docs: 56 }
            ];
            
            const topics = [
                { id: 'United States Air Force', type: 'topic', degree: 15, docs: 209 },
                { id: 'China', type: 'topic', degree: 12, docs: 163 },
                { id: 'Russia', type: 'topic', degree: 10, docs: 150 },
                { id: 'United States Army', type: 'topic', degree: 11, docs: 136 },
                { id: 'COVID-19', type: 'topic', degree: 14, docs: 136 },
                { id: 'Military Strategy', type: 'topic', degree: 9, docs: 112 },
                { id: 'Teachers and Teaching', type: 'topic', degree: 8, docs: 110 },
                { id: 'Artificial Intelligence', type: 'topic', degree: 7, docs: 76 }
            ];
            
            nodes.push(...authors, ...topics);
            
            // Generate author-topic connections
            authors.forEach(author => {
                const numTopics = Math.floor(Math.random() * 4) + 2;
                const authorTopics = topics.sort(() => 0.5 - Math.random()).slice(0, numTopics);
                
                authorTopics.forEach(topic => {
                    links.push({
                        source: author.id,
                        target: topic.id,
                        weight: Math.floor(Math.random() * 15) + 1
                    });
                });
            });
            
            return { nodes, links };
        }

        function generateMethodAINetwork() {
            const nodes = [];
            const links = [];
            
            const methods = [
                { id: 'Literature Review', type: 'method', degree: 12, docs: 909 },
                { id: 'Statistical Analysis', type: 'method', degree: 15, docs: 688 },
                { id: 'Data Analysis', type: 'method', degree: 18, docs: 177 },
                { id: 'Comparative Analysis', type: 'method', degree: 8, docs: 307 },
                { id: 'Algorithmic Analysis', type: 'method', degree: 10, docs: 85 }
            ];
            
            const aiTechs = [
                { id: 'Machine Learning (ML)', type: 'ai', degree: 20, docs: 60 },
                { id: 'Natural Language Processing (NLP)', type: 'ai', degree: 15, docs: 47 },
                { id: 'Artificial Intelligence (AI)', type: 'ai', degree: 12, docs: 32 },
                { id: 'Large Language Models (LLMs)', type: 'ai', degree: 8, docs: 18 },
                { id: 'Deep Learning', type: 'ai', degree: 10, docs: 16 },
                { id: 'Neural Networks', type: 'ai', degree: 6, docs: 11 },
                { id: 'Computer Vision', type: 'ai', degree: 5, docs: 11 }
            ];
            
            nodes.push(...methods, ...aiTechs);
            
            // Generate method-AI connections
            methods.forEach(method => {
                aiTechs.forEach(ai => {
                    if (Math.random() < 0.4) {
                        links.push({
                            source: method.id,
                            target: ai.id,
                            weight: Math.floor(Math.random() * 12) + 1
                        });
                    }
                });
            });
            
            return { nodes, links };
        }

        function generateUnitMethodNetwork() {
            const nodes = [];
            const links = [];
            
            const units = [
                { id: 'Project AIR FORCE', type: 'unit', degree: 15, docs: 72 },
                { id: 'National Defense Research Institute', type: 'unit', degree: 12, docs: 61 },
                { id: 'American Educator Panels', type: 'unit', degree: 8, docs: 57 },
                { id: 'Arroyo Center', type: 'unit', degree: 10, docs: 48 },
                { id: 'HSOAC', type: 'unit', degree: 9, docs: 48 },
                { id: 'RAND Europe', type: 'unit', degree: 7, docs: 42 }
            ];
            
            const methods = [
                { id: 'Literature Review', type: 'method', degree: 18, docs: 909 },
                { id: 'Statistical Analysis', type: 'method', degree: 15, docs: 688 },
                { id: 'Interviews', type: 'method', degree: 12, docs: 391 },
                { id: 'Surveys', type: 'method', degree: 10, docs: 195 },
                { id: 'Case Study Analysis', type: 'method', degree: 8, docs: 188 }
            ];
            
            nodes.push(...units, ...methods);
            
            // Generate unit-method connections
            units.forEach(unit => {
                methods.forEach(method => {
                    if (Math.random() < 0.6) {
                        links.push({
                            source: unit.id,
                            target: method.id,
                            weight: Math.floor(Math.random() * 20) + 1
                        });
                    }
                });
            });
            
            return { nodes, links };
        }

        function generateTemporalAuthorNetwork() {
            // This would show author activity over time
            // For simplicity, using the author collaboration network
            return generateAuthorCollaborationNetwork();
        }

        function updateVisualization() {
            if (!currentData) return;
            
            const threshold = parseInt(document.getElementById('nodeThreshold').value);
            
            // Filter nodes based on threshold
            const filteredNodes = currentData.nodes.filter(node => node.degree >= threshold);
            const nodeIds = new Set(filteredNodes.map(node => node.id));
            const filteredLinks = currentData.links.filter(link => 
                nodeIds.has(link.source.id || link.source) && 
                nodeIds.has(link.target.id || link.target)
            );
            
            updateNetworkStats(filteredNodes, filteredLinks);
            drawNetwork(filteredNodes, filteredLinks);
            updateLegend();
        }

        function updateNetworkStats(nodes, links) {
            const avgDegree = links.length > 0 ? (links.length * 2 / nodes.length).toFixed(1) : 0;
            const maxPossibleLinks = nodes.length * (nodes.length - 1) / 2;
            const density = maxPossibleLinks > 0 ? (links.length / maxPossibleLinks * 100).toFixed(1) + '%' : '0%';
            
            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('linkCount').textContent = links.length;
            document.getElementById('avgDegree').textContent = avgDegree;
            document.getElementById('density').textContent = density;
        }

        function drawNetwork(nodes, links) {
            // Clear existing elements
            g.selectAll('*').remove();
            
            // Create links
            link = g.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke-width', d => Math.sqrt(d.weight || 1));
            
            // Create nodes
            node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('class', d => `node ${d.type}`)
                .attr('r', d => Math.sqrt(d.degree) + 3)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('mouseover', handleMouseOver)
                .on('mouseout', handleMouseOut);
            
            // Add node labels
            nodeLabel = g.append('g')
                .attr('class', 'node-labels')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .attr('class', 'node-label')
                .text(d => d.id.length > 20 ? d.id.substring(0, 17) + '...' : d.id);
            
            // Update simulation
            simulation.nodes(nodes);
            simulation.force('link').links(links);
            simulation.alpha(1).restart();
            
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                nodeLabel
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 4);
            });
        }

        function updateLayout() {
            const layoutType = document.getElementById('layoutType').value;
            
            // Update force simulation based on layout type
            if (layoutType === 'circular') {
                simulation
                    .force('center', null)
                    .force('charge', d3.forceManyBody().strength(-50));
                
                // Position nodes in a circle
                const radius = Math.min(400, 300);
                const angleStep = (2 * Math.PI) / simulation.nodes().length;
                simulation.nodes().forEach((node, i) => {
                    node.x = 400 + radius * Math.cos(i * angleStep);
                    node.y = 350 + radius * Math.sin(i * angleStep);
                });
            } else if (layoutType === 'hierarchical') {
                simulation
                    .force('center', d3.forceCenter(400, 350))
                    .force('charge', d3.forceManyBody().strength(-100));
                
                // Simple hierarchical layout by node type
                const nodesByType = d3.group(simulation.nodes(), d => d.type);
                let y = 100;
                nodesByType.forEach((nodes, type) => {
                    nodes.forEach((node, i) => {
                        node.x = 100 + i * 50;
                        node.y = y;
                    });
                    y += 150;
                });
            } else {
                // Force-directed (default)
                simulation
                    .force('center', d3.forceCenter(400, 350))
                    .force('charge', d3.forceManyBody().strength(-100));
            }
            
            simulation.alpha(1).restart();
        }

        function updateColors() {
            const colorScheme = document.getElementById('colorScheme').value;
            
            if (colorScheme === 'degree') {
                const maxDegree = d3.max(simulation.nodes(), d => d.degree);
                const colorScale = d3.scaleSequential(d3.interpolateViridis)
                    .domain([0, maxDegree]);
                
                node.style('fill', d => colorScale(d.degree));
            } else if (colorScheme === 'community') {
                // Simple community detection (assign random communities for demo)
                const communities = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00'];
                node.style('fill', (d, i) => communities[i % communities.length]);
            } else {
                // Color by type (default)
                node.attr('class', d => `node ${d.type}`);
            }
        }

        function updateLegend() {
            const networkType = document.getElementById('networkType').value;
            const legendData = getLegendData(networkType);
            
            const legend = d3.select('#legend');
            legend.selectAll('*').remove();
            
            legend.append('h4')
                .style('margin', '0 0 10px 0')
                .style('color', '#0073e6')
                .text('Legend');
            
            const legendItems = legend.selectAll('.legend-item')
                .data(legendData)
                .enter().append('div')
                .attr('class', 'legend-item');
            
            legendItems.append('div')
                .attr('class', 'legend-color')
                .style('background-color', d => d.color);
            
            legendItems.append('span')
                .text(d => d.label);
        }

        function getLegendData(networkType) {
            const baseTypes = {
                'author': { color: '#0073e6', label: 'Authors' },
                'method': { color: '#28a745', label: 'Methods' },
                'ai': { color: '#dc3545', label: 'AI Technologies' },
                'topic': { color: '#ffc107', label: 'Topics' },
                'unit': { color: '#6f42c1', label: 'Units' }
            };
            
            const typeMap = {
                'author-method': ['author', 'method'],
                'author-author': ['author'],
                'method-method': ['method'],
                'author-topic': ['author', 'topic'],
                'method-ai': ['method', 'ai'],
                'unit-method': ['unit', 'method'],
                'temporal-author': ['author']
            };
            
            return typeMap[networkType].map(type => baseTypes[type]);
        }

        // Event handlers
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function handleMouseOver(event, d) {
            // Highlight connected nodes and links
            const connectedNodes = new Set([d.id]);
            const connectedLinks = link.data().filter(l => 
                l.source.id === d.id || l.target.id === d.id
            );
            
            connectedLinks.forEach(l => {
                connectedNodes.add(l.source.id);
                connectedNodes.add(l.target.id);
            });
            
            node.style('opacity', n => connectedNodes.has(n.id) ? 1 : 0.2);
            link.classed('highlighted', l => 
                l.source.id === d.id || l.target.id === d.id
            );
            
            // Show tooltip
            const tooltip = `${d.id}\nType: ${d.type}\nDegree: ${d.degree}\nDocuments: ${d.docs || 'N/A'}`;
            console.log(tooltip); // In a full implementation, show a proper tooltip
        }

        function handleMouseOut(event, d) {
            node.style('opacity', 1);
            link.classed('highlighted', false);
        }

        // Handle window resize
        window.addEventListener('resize', function() {
            const container = document.querySelector('.visualization-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            svg.attr('width', width).attr('height', height);
            simulation.force('center', d3.forceCenter(width / 2, height / 2));
            simulation.alpha(1).restart();
        });
    </script>
</body>
</html>